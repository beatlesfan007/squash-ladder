// Import generated proto message types
// These are generated by ts_proto_library from rules_proto_grpc
// Note: Import paths may need adjustment based on actual generated code structure
// Import generated proto message types
// These are generated by ts_proto_library from rules_proto_grpc
// Note: Import paths may need adjustment based on actual generated code structure
import {
  Player,
  ListPlayersRequest,
  ListPlayersResponse,
  AddPlayerRequest,
  AddPlayerResponse,
  AddMatchResultRequest,
  AddMatchResultResponse,
  SetScore,
  ListRecentMatchesRequest,
  ListRecentMatchesResponse,
  MatchResult,
} from './ladder_pb'

// Import generated gRPC-Web service client
// This is generated by js_grpc_web_library from rules_proto_grpc
// Note: js_grpc_web_library may generate code for official grpc-web library
// If so, the API and import paths will need adjustment
import { LadderServiceClient } from './ladder_grpc_web_pb'

// Re-export types for convenience
export type {
  Player,
  ListPlayersRequest,
  ListPlayersResponse,
  MatchResult,
}

// Re-export classes
export {
  SetScore,
}

// Create a service client instance
// The generated client provides type-safe methods for each RPC
const client = new LadderServiceClient('/players')

// Service wrapper that uses the generated client
// This provides a cleaner async/await interface over the generated client
export const ladderService = {
  listPlayers: async (): Promise<ListPlayersResponse> => {
    return new Promise((resolve, reject) => {
      const request = new ListPlayersRequest()
      client.listPlayers(request, {}, (err: any, response: any) => {
        if (err) {
          reject(new Error(`gRPC error: ${err.message || 'Unknown error'}`))
        } else if (response) {
          resolve(response)
        } else {
          reject(new Error('No response received'))
        }
      })
    })
  },

  addPlayer: async (name: string): Promise<Player> => {
    return new Promise((resolve, reject) => {
      const request = new AddPlayerRequest()
      request.setName(name)

      client.addPlayer(request, {}, (err: any, response: AddPlayerResponse) => {
        if (err) {
          reject(new Error(`gRPC error: ${err.message || 'Unknown error'}`))
        } else if (response) {
          const player = response.getPlayer()
          if (player) {
            resolve(player)
          } else {
            reject(new Error('No player returned in response'))
          }
        } else {
          reject(new Error('No response received'))
        }
      })
    })
  },

  addMatchResult: async (
    challengerId: string,
    defenderId: string,
    winnerId: string,
    setScores: SetScore[]
  ): Promise<boolean> => {
    return new Promise((resolve, reject) => {
      const request = new AddMatchResultRequest()
      request.setChallengerId(challengerId)
      request.setDefenderId(defenderId)
      request.setWinnerId(winnerId)
      request.setSetScoresList(setScores)

      client.addMatchResult(request, {}, (err: any, response: AddMatchResultResponse) => {
        if (err) {
          reject(new Error(`gRPC error: ${err.message || 'Unknown error'}`))
        } else if (response) {
          resolve(response.getSuccess())
        } else {
          reject(new Error('No response received'))
        }
      })
    })
  },

  listRecentMatches: async (limit: number): Promise<MatchResult[]> => {
    return new Promise((resolve, reject) => {
      const request = new ListRecentMatchesRequest()
      request.setLimit(limit)

      client.listRecentMatches(request, {}, (err: any, response: ListRecentMatchesResponse) => {
        if (err) {
          reject(new Error(`gRPC error: ${err.message || 'Unknown error'}`))
        } else if (response) {
          resolve(response.getResultsList())
        } else {
          reject(new Error('No response received'))
        }
      })
    })
  }
}
